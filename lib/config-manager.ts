import { readFile, writeFile, mkdir, access, copyFile } from 'fs/promises'
import { join, dirname, basename } from 'path'
import ini from 'ini'
import type { ServerConfig } from '@/types/ark'

/**
 * Config Manager - Manages ARK server configuration files
 * 
 * ark-server-tools 配置方式：
 * 1. 实例配置文件 (.cfg) 中的 ark_ 参数 - 推荐方式
 * 2. 独立的 GameUserSettings.ini 文件（通过 arkGameUserSettingsIniFile 指定）
 */
export class ConfigManager {
  /**
   * Read configuration from instance .cfg file
   * This reads ark_ prefixed parameters from /etc/arkmanager/instances/<instance>.cfg
   * Also reads serverMap and other non-ark_ parameters
   */
  async readInstanceConfigFile(configPath: string): Promise<ServerConfig> {
    try {
      const content = await readFile(configPath, 'utf-8')
      const config: ServerConfig = {}

      const lines = content.split('\n')
      for (const line of lines) {
        const trimmed = line.trim()
        if (!trimmed || trimmed.startsWith('#')) continue

        // Match ark_ parameters, serverMap, or arkAutoUpdateOnStart, arkBackupPreUpdate, arkAlwaysRestartOnCrash
        const arkMatch = trimmed.match(/^ark_([^=]+)=(.+)$/)
        const serverMapMatch = trimmed.match(/^serverMap=(.+)$/)
        const arkAutoUpdateMatch = trimmed.match(/^arkAutoUpdateOnStart=(.+)$/)
        const arkBackupPreUpdateMatch = trimmed.match(/^arkBackupPreUpdate=(.+)$/)
        const arkAlwaysRestartMatch = trimmed.match(/^arkAlwaysRestartOnCrash=(.+)$/)

        let key: string | null = null
        let value: string | null = null

        if (arkMatch) {
          key = arkMatch[1].trim()
          value = arkMatch[2].trim()
        } else if (serverMapMatch) {
          key = 'serverMap'
          value = serverMapMatch[1].trim()
        } else if (arkAutoUpdateMatch) {
          key = 'AutoUpdateOnStart'
          value = arkAutoUpdateMatch[1].trim()
        } else if (arkBackupPreUpdateMatch) {
          key = 'BackupPreUpdate'
          value = arkBackupPreUpdateMatch[1].trim()
        } else if (arkAlwaysRestartMatch) {
          key = 'AlwaysRestartOnCrash'
          value = arkAlwaysRestartMatch[1].trim()
        }

        if (key && value !== null) {
          // Extract value from quotes if present
          if ((value.startsWith('"') && value.includes('"', 1)) ||
            (value.startsWith("'") && value.includes("'", 1))) {
            const quoteChar = value[0]
            const closeQuoteIndex = value.indexOf(quoteChar, 1)
            if (closeQuoteIndex !== -1) {
              value = value.substring(1, closeQuoteIndex)
            }
          } else {
            // Remove inline comments
            const commentIndex = value.indexOf('#')
            if (commentIndex !== -1) {
              value = value.substring(0, commentIndex).trim()
            }
          }

          // Remove any remaining quotes
          value = value.replace(/^["']|["']$/g, '')

          // Convert to appropriate type
          if (value === 'True' || value === 'true') {
            config[key] = true
          } else if (value === 'False' || value === 'false') {
            config[key] = false
          } else if (!isNaN(Number(value)) && value !== '') {
            config[key] = Number(value)
          } else {
            config[key] = value
          }
        }
      }

      return config
    } catch (error: any) {
      console.error('Error reading instance config file:', error)
      throw error
    }
  }

  /**
   * Write configuration to instance .cfg file
   * Updates ark_ prefixed parameters in /etc/arkmanager/instances/<instance>.cfg
   * 
   * This preserves the original file structure and only updates changed values
   * 
   * Note: Requires write permission to the config directory
   * Solutions if permission denied:
   * 1. Run Node.js as steam user
   * 2. Use user-level config: ~/.config/arkmanager/instances/
   * 3. Change directory permissions
   */
  async writeInstanceConfigFile(configPath: string, config: ServerConfig): Promise<void> {
    try {
      // Read existing config file
      let content = ''
      try {
        content = await readFile(configPath, 'utf-8')
      } catch (error: any) {
        if (error.code === 'ENOENT') {
          // File doesn't exist, create basic template with required arkserverroot
          const arkServerRoot = process.env.ARK_SERVERS_PATH || '/home/steam/ARK'
          content = '# ARK Server Instance Configuration\n# Auto-generated by ARK Server Manager\n\n'
          content += `# ARK server files location\n`
          content += `arkserverroot="${arkServerRoot}"\n\n`
          content += '# ARK server options - use ark_<optionname>=<value>\n'
          content += '# Server configuration\n\n'
        } else if (error.code === 'EACCES') {
          throw new Error(`Permission denied to read ${configPath}. Please run the application as the steam user or adjust file permissions.`)
        } else {
          throw error
        }
      }

      const lines = content.split('\n')
      const updatedLines: string[] = []
      const processedKeys = new Set<string>()

      // Update existing lines
      for (const line of lines) {
        const trimmed = line.trim()

        // Keep comments and empty lines
        if (!trimmed || trimmed.startsWith('#')) {
          updatedLines.push(line)
          continue
        }

        // Match ark_ parameters
        const arkMatch = trimmed.match(/^ark_([^=]+)=/)
        const serverMapMatch = trimmed.match(/^serverMap=/)

        if (arkMatch) {
          const key = arkMatch[1].trim()

          if (config[key] !== undefined) {
            // Update this line with new value
            const value = config[key]
            const formattedValue = typeof value === 'string' ? `"${value}"` : value

            // Preserve inline comments if they exist
            const commentMatch = line.match(/(#.+)$/)
            const comment = commentMatch ? `                               ${commentMatch[1]}` : ''

            updatedLines.push(`ark_${key}=${formattedValue}${comment}`)
            processedKeys.add(key)
          } else {
            // Keep original line
            updatedLines.push(line)
          }
        } else if (serverMapMatch && config.serverMap !== undefined) {
          // Update serverMap
          const formattedValue = typeof config.serverMap === 'string' ? `"${config.serverMap}"` : config.serverMap
          const commentMatch = line.match(/(#.+)$/)
          const comment = commentMatch ? `                               ${commentMatch[1]}` : ''
          updatedLines.push(`serverMap=${formattedValue}${comment}`)
          processedKeys.add('serverMap')
        } else if (trimmed.match(/^arkAutoUpdateOnStart=/)) {
          if (config.AutoUpdateOnStart !== undefined) {
            const value = config.AutoUpdateOnStart ? 'true' : 'false'
            updatedLines.push(`arkAutoUpdateOnStart="${value}"`)
            processedKeys.add('AutoUpdateOnStart')
          } else {
            updatedLines.push(line)
          }
        } else if (trimmed.match(/^arkBackupPreUpdate=/)) {
          if (config.BackupPreUpdate !== undefined) {
            const value = config.BackupPreUpdate ? 'true' : 'false'
            updatedLines.push(`arkBackupPreUpdate="${value}"`)
            processedKeys.add('BackupPreUpdate')
          } else {
            updatedLines.push(line)
          }
        } else if (trimmed.match(/^arkAlwaysRestartOnCrash=/)) {
          if (config.AlwaysRestartOnCrash !== undefined) {
            const value = config.AlwaysRestartOnCrash ? 'true' : 'false'
            updatedLines.push(`arkAlwaysRestartOnCrash="${value}"`)
            processedKeys.add('AlwaysRestartOnCrash')
          } else {
            updatedLines.push(line)
          }
        } else {
          // Keep non-ark lines (like arkserverroot, etc.)
          updatedLines.push(line)
        }
      }

      // Add new config entries that weren't in the file
      const specialKeys = ['serverMap', 'AutoUpdateOnStart', 'BackupPreUpdate', 'AlwaysRestartOnCrash']

      for (const [key, value] of Object.entries(config)) {
        if (!processedKeys.has(key) && !specialKeys.includes(key)) {
          const formattedValue = typeof value === 'string' ? `"${value}"` : value
          updatedLines.push(`ark_${key}=${formattedValue}`)
        }
      }

      // Add special keys if not processed
      if (!processedKeys.has('AutoUpdateOnStart') && config.AutoUpdateOnStart !== undefined) {
        const value = config.AutoUpdateOnStart ? 'true' : 'false'
        updatedLines.push(`arkAutoUpdateOnStart="${value}"`)
      }
      if (!processedKeys.has('BackupPreUpdate') && config.BackupPreUpdate !== undefined) {
        const value = config.BackupPreUpdate ? 'true' : 'false'
        updatedLines.push(`arkBackupPreUpdate="${value}"`)
      }
      if (!processedKeys.has('AlwaysRestartOnCrash') && config.AlwaysRestartOnCrash !== undefined) {
        const value = config.AlwaysRestartOnCrash ? 'true' : 'false'
        updatedLines.push(`arkAlwaysRestartOnCrash="${value}"`)
      }
      if (!processedKeys.has('serverMap') && config.serverMap !== undefined) {
        const formattedValue = typeof config.serverMap === 'string' ? `"${config.serverMap}"` : config.serverMap
        updatedLines.push(`serverMap=${formattedValue}`)
      }

      const newContent = updatedLines.join('\n')

      try {
        await writeFile(configPath, newContent, 'utf-8')
      } catch (error: any) {
        if (error.code === 'EACCES') {
          throw new Error(
            `Permission denied to write ${configPath}. ` +
            `Solutions: ` +
            `1) Run application as steam user, ` +
            `2) Set ARK_INSTANCE_CONFIG_DIR to ~/.config/arkmanager/instances, ` +
            `3) Change permissions: sudo chown -R steam:steam /etc/arkmanager`
          )
        }
        throw error
      }
    } catch (error: any) {
      console.error('Error writing instance config file:', error)
      throw error
    }
  }

  /**
   * Read GameUserSettings.ini (legacy, for reference only)
   */
  async readGameUserSettings(configPath: string): Promise<ServerConfig> {
    try {
      const content = await readFile(configPath, 'utf-8')
      const parsed = ini.parse(content)

      // Extract relevant sections
      const sessionSettings = parsed.SessionSettings || {}
      const serverSettings = parsed.ServerSettings || {}
      const shooterGameMode = parsed['/Script/ShooterGame.ShooterGameMode'] || {}

      return {
        ...sessionSettings,
        ...serverSettings,
        ...shooterGameMode
      }
    } catch (error: any) {
      console.error('Error reading GameUserSettings.ini:', error)
      throw error
    }
  }

  /**
   * Write GameUserSettings.ini (legacy)
   */
  async writeGameUserSettings(configPath: string, config: ServerConfig): Promise<void> {
    try {
      const iniContent: {
        SessionSettings: Record<string, any>
        ServerSettings: Record<string, any>
        '/Script/ShooterGame.ShooterGameMode': Record<string, any>
      } = {
        SessionSettings: {},
        ServerSettings: {},
        '/Script/ShooterGame.ShooterGameMode': {}
      }

      // Distribute settings to appropriate sections
      const sessionKeys = ['SessionName', 'MaxPlayers', 'ServerPassword', 'ServerAdminPassword']

      for (const [key, value] of Object.entries(config)) {
        if (sessionKeys.includes(key)) {
          iniContent.SessionSettings[key] = value
        } else {
          iniContent['/Script/ShooterGame.ShooterGameMode'][key] = value
        }
      }

      const content = ini.stringify(iniContent)
      await writeFile(configPath, content, 'utf-8')
    } catch (error: any) {
      console.error('Error writing GameUserSettings.ini:', error)
      throw error
    }
  }

  /**
   * Read Game.ini
   */
  async readGameIni(configPath: string): Promise<any> {
    try {
      const content = await readFile(configPath, 'utf-8')
      return ini.parse(content)
    } catch (error: any) {
      console.error('Error reading Game.ini:', error)
      throw error
    }
  }

  /**
   * Write Game.ini
   */
  async writeGameIni(configPath: string, config: any): Promise<void> {
    try {
      const content = ini.stringify(config)
      await writeFile(configPath, content, 'utf-8')
    } catch (error: any) {
      console.error('Error writing Game.ini:', error)
      throw error
    }
  }

  /**
   * Merge configurations
   */
  mergeConfig(existing: ServerConfig, updates: Partial<ServerConfig>): ServerConfig {
    return {
      ...existing,
      ...updates
    }
  }

  /**
   * Validate configuration
   */
  validateConfig(config: ServerConfig): { valid: boolean; errors: string[] } {
    const errors: string[] = []

    // Validate max players
    if (config.MaxPlayers !== undefined && (config.MaxPlayers < 1 || config.MaxPlayers > 100)) {
      errors.push('MaxPlayers must be between 1 and 100')
    }

    // Validate ports (must be in valid range)
    if (config.Port !== undefined && (config.Port < 1024 || config.Port > 65535)) {
      errors.push('Port must be between 1024 and 65535')
    }
    if (config.QueryPort !== undefined && (config.QueryPort < 1024 || config.QueryPort > 65535)) {
      errors.push('QueryPort must be between 1024 and 65535')
    }
    if (config.RCONPort !== undefined && (config.RCONPort < 1024 || config.RCONPort > 65535)) {
      errors.push('RCONPort must be between 1024 and 65535')
    }

    // Validate session name (warn about special characters)
    if (config.SessionName && /[!@#$%^&*()+=\[\]{}|\\;:<>?]/.test(config.SessionName)) {
      errors.push('SessionName contains special characters which may cause issues. Consider defining it in GameUserSettings.ini instead.')
    }

    return {
      valid: errors.length === 0,
      errors
    }
  }

  /**
   * Get default configuration
   */
  getDefaultConfig(): ServerConfig {
    return {
      SessionName: 'ARK Server',
      ServerPassword: '',
      ServerAdminPassword: 'admin123',
      MaxPlayers: 70,
      AllowThirdPersonPlayer: true,
      ShowMapPlayerLocation: true,
      ServerPVE: true,
      EnablePVPGamma: false
    }
  }

  /**
   * Read game configuration file as raw text
   * Used for GameUserSettings.ini and Game.ini
   */
  async readGameConfigFile(filePath: string): Promise<string> {
    try {
      const content = await readFile(filePath, 'utf-8')
      return content
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        // File doesn't exist, return empty string
        return ''
      }
      throw error
    }
  }

  /**
   * Write game configuration file with automatic backup
   * Backs up existing file before writing new content
   */
  async writeGameConfigFile(filePath: string, content: string, backupDir?: string): Promise<void> {
    try {
      // Check if file exists and backup if it does
      try {
        await access(filePath)
        // File exists, create backup
        if (backupDir) {
          await this.backupConfigFile(filePath, backupDir)
        }
      } catch (error: any) {
        if (error.code !== 'ENOENT') {
          throw error
        }
        // File doesn't exist, no backup needed
      }

      // Ensure directory exists
      const dir = dirname(filePath)
      await mkdir(dir, { recursive: true })

      // Write new content
      await writeFile(filePath, content, 'utf-8')
    } catch (error: any) {
      console.error('Error writing game config file:', error)
      throw error
    }
  }

  /**
   * Backup configuration file to backup directory
   * Returns the path to the backup file
   */
  async backupConfigFile(filePath: string, backupDir: string): Promise<string> {
    try {
      // Ensure backup directory exists
      await mkdir(backupDir, { recursive: true })

      // Generate backup filename with timestamp
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19)
      const filename = basename(filePath)
      const backupFilename = `${filename}.bak-${timestamp}`
      const backupPath = join(backupDir, backupFilename)

      // Copy file to backup location
      await copyFile(filePath, backupPath)

      return backupPath
    } catch (error: any) {
      console.error('Error backing up config file:', error)
      throw error
    }
  }

  /**
   * Get the full path to a game configuration file in instances directory
   * According to ark-server-tools, config files should be stored in instances directory
   * with format: /etc/arkmanager/instances/<instance>.GameUserSettings.ini
   * 
   * arkmanager will automatically copy these files to the server directory on startup
   */
  async getGameConfigFilePath(instance: string, fileType: 'GameUserSettings' | 'Game'): Promise<string> {
    try {
      const instanceConfigDir = process.env.ARK_INSTANCE_CONFIG_DIR || '/etc/arkmanager/instances'
      const filename = fileType === 'GameUserSettings' ? 'GameUserSettings.ini' : 'Game.ini'

      // Return path in instances directory, following ark-server-tools convention
      // e.g. /etc/arkmanager/instances/main.GameUserSettings.ini
      return `${instanceConfigDir}/${instance}.${filename}`
    } catch (error: any) {
      console.error('Error getting game config file path:', error)
      throw error
    }
  }
}

// Export singleton instance
export const configManager = new ConfigManager()
