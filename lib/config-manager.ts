import { readFile, writeFile } from 'fs/promises'
import ini from 'ini'
import type { ServerConfig } from '@/types/ark'

/**
 * Config Manager - Manages ARK server configuration files
 * 
 * ark-server-tools 配置方式：
 * 1. 实例配置文件 (.cfg) 中的 ark_ 参数 - 推荐方式
 * 2. 独立的 GameUserSettings.ini 文件（通过 arkGameUserSettingsIniFile 指定）
 */
export class ConfigManager {
  /**
   * Read configuration from instance .cfg file
   * This reads ark_ prefixed parameters from /etc/arkmanager/instances/<instance>.cfg
   * Also reads serverMap and other non-ark_ parameters
   */
  async readInstanceConfigFile(configPath: string): Promise<ServerConfig> {
    try {
      const content = await readFile(configPath, 'utf-8')
      const config: ServerConfig = {}
      
      const lines = content.split('\n')
      for (const line of lines) {
        const trimmed = line.trim()
        if (!trimmed || trimmed.startsWith('#')) continue
        
        // Match ark_ parameters, serverMap, or arkAutoUpdateOnStart, arkBackupPreUpdate, arkAlwaysRestartOnCrash
        const arkMatch = trimmed.match(/^ark_([^=]+)=(.+)$/)
        const serverMapMatch = trimmed.match(/^serverMap=(.+)$/)
        const arkAutoUpdateMatch = trimmed.match(/^arkAutoUpdateOnStart=(.+)$/)
        const arkBackupPreUpdateMatch = trimmed.match(/^arkBackupPreUpdate=(.+)$/)
        const arkAlwaysRestartMatch = trimmed.match(/^arkAlwaysRestartOnCrash=(.+)$/)
        
        let key: string | null = null
        let value: string | null = null
        
        if (arkMatch) {
          key = arkMatch[1].trim()
          value = arkMatch[2].trim()
        } else if (serverMapMatch) {
          key = 'serverMap'
          value = serverMapMatch[1].trim()
        } else if (arkAutoUpdateMatch) {
          key = 'AutoUpdateOnStart'
          value = arkAutoUpdateMatch[1].trim()
        } else if (arkBackupPreUpdateMatch) {
          key = 'BackupPreUpdate'
          value = arkBackupPreUpdateMatch[1].trim()
        } else if (arkAlwaysRestartMatch) {
          key = 'AlwaysRestartOnCrash'
          value = arkAlwaysRestartMatch[1].trim()
        }
        
        if (key && value !== null) {
          // Extract value from quotes if present
          if ((value.startsWith('"') && value.includes('"', 1)) || 
              (value.startsWith("'") && value.includes("'", 1))) {
            const quoteChar = value[0]
            const closeQuoteIndex = value.indexOf(quoteChar, 1)
            if (closeQuoteIndex !== -1) {
              value = value.substring(1, closeQuoteIndex)
            }
          } else {
            // Remove inline comments
            const commentIndex = value.indexOf('#')
            if (commentIndex !== -1) {
              value = value.substring(0, commentIndex).trim()
            }
          }
          
          // Remove any remaining quotes
          value = value.replace(/^["']|["']$/g, '')
          
          // Convert to appropriate type
          if (value === 'True' || value === 'true') {
            config[key] = true
          } else if (value === 'False' || value === 'false') {
            config[key] = false
          } else if (!isNaN(Number(value)) && value !== '') {
            config[key] = Number(value)
          } else {
            config[key] = value
          }
        }
      }
      
      return config
    } catch (error: any) {
      console.error('Error reading instance config file:', error)
      throw error
    }
  }

  /**
   * Write configuration to instance .cfg file
   * Updates ark_ prefixed parameters in /etc/arkmanager/instances/<instance>.cfg
   * 
   * This preserves the original file structure and only updates changed values
   */
  async writeInstanceConfigFile(configPath: string, config: ServerConfig): Promise<void> {
    try {
      // Read existing config file
      let content = ''
      try {
        content = await readFile(configPath, 'utf-8')
      } catch (error) {
        // File doesn't exist, create basic template
        content = '# ARK Server Instance Configuration\n# Auto-generated by ARK Server Manager\n\n'
      }
      
      const lines = content.split('\n')
      const updatedLines: string[] = []
      const processedKeys = new Set<string>()
      
      // Update existing lines
      for (const line of lines) {
        const trimmed = line.trim()
        
        // Keep comments and empty lines
        if (!trimmed || trimmed.startsWith('#')) {
          updatedLines.push(line)
          continue
        }
        
        // Match ark_ parameters
        const arkMatch = trimmed.match(/^ark_([^=]+)=/)
        const serverMapMatch = trimmed.match(/^serverMap=/)
        
        if (arkMatch) {
          const key = arkMatch[1].trim()
          
          if (config[key] !== undefined) {
            // Update this line with new value
            const value = config[key]
            const formattedValue = typeof value === 'string' ? `"${value}"` : value
            
            // Preserve inline comments if they exist
            const commentMatch = line.match(/(#.+)$/)
            const comment = commentMatch ? `                               ${commentMatch[1]}` : ''
            
            updatedLines.push(`ark_${key}=${formattedValue}${comment}`)
            processedKeys.add(key)
          } else {
            // Keep original line
            updatedLines.push(line)
          }
        } else if (serverMapMatch && config.serverMap !== undefined) {
          // Update serverMap
          const formattedValue = typeof config.serverMap === 'string' ? `"${config.serverMap}"` : config.serverMap
          const commentMatch = line.match(/(#.+)$/)
          const comment = commentMatch ? `                               ${commentMatch[1]}` : ''
          updatedLines.push(`serverMap=${formattedValue}${comment}`)
          processedKeys.add('serverMap')
        } else if (trimmed.match(/^arkAutoUpdateOnStart=/)) {
          if (config.AutoUpdateOnStart !== undefined) {
            const value = config.AutoUpdateOnStart ? 'true' : 'false'
            updatedLines.push(`arkAutoUpdateOnStart="${value}"`)
            processedKeys.add('AutoUpdateOnStart')
          } else {
            updatedLines.push(line)
          }
        } else if (trimmed.match(/^arkBackupPreUpdate=/)) {
          if (config.BackupPreUpdate !== undefined) {
            const value = config.BackupPreUpdate ? 'true' : 'false'
            updatedLines.push(`arkBackupPreUpdate="${value}"`)
            processedKeys.add('BackupPreUpdate')
          } else {
            updatedLines.push(line)
          }
        } else if (trimmed.match(/^arkAlwaysRestartOnCrash=/)) {
          if (config.AlwaysRestartOnCrash !== undefined) {
            const value = config.AlwaysRestartOnCrash ? 'true' : 'false'
            updatedLines.push(`arkAlwaysRestartOnCrash="${value}"`)
            processedKeys.add('AlwaysRestartOnCrash')
          } else {
            updatedLines.push(line)
          }
        } else {
          // Keep non-ark lines (like arkserverroot, etc.)
          updatedLines.push(line)
        }
      }
      
      // Add new config entries that weren't in the file
      const specialKeys = ['serverMap', 'AutoUpdateOnStart', 'BackupPreUpdate', 'AlwaysRestartOnCrash']
      
      for (const [key, value] of Object.entries(config)) {
        if (!processedKeys.has(key) && !specialKeys.includes(key)) {
          const formattedValue = typeof value === 'string' ? `"${value}"` : value
          updatedLines.push(`ark_${key}=${formattedValue}`)
        }
      }
      
      // Add special keys if not processed
      if (!processedKeys.has('AutoUpdateOnStart') && config.AutoUpdateOnStart !== undefined) {
        const value = config.AutoUpdateOnStart ? 'true' : 'false'
        updatedLines.push(`arkAutoUpdateOnStart="${value}"`)
      }
      if (!processedKeys.has('BackupPreUpdate') && config.BackupPreUpdate !== undefined) {
        const value = config.BackupPreUpdate ? 'true' : 'false'
        updatedLines.push(`arkBackupPreUpdate="${value}"`)
      }
      if (!processedKeys.has('AlwaysRestartOnCrash') && config.AlwaysRestartOnCrash !== undefined) {
        const value = config.AlwaysRestartOnCrash ? 'true' : 'false'
        updatedLines.push(`arkAlwaysRestartOnCrash="${value}"`)
      }
      
      const newContent = updatedLines.join('\n')
      await writeFile(configPath, newContent, 'utf-8')
    } catch (error: any) {
      console.error('Error writing instance config file:', error)
      throw error
    }
  }

  /**
   * Read GameUserSettings.ini (legacy, for reference only)
   */
  async readGameUserSettings(configPath: string): Promise<ServerConfig> {
    try {
      const content = await readFile(configPath, 'utf-8')
      const parsed = ini.parse(content)
      
      // Extract relevant sections
      const sessionSettings = parsed.SessionSettings || {}
      const serverSettings = parsed.ServerSettings || {}
      const shooterGameMode = parsed['/Script/ShooterGame.ShooterGameMode'] || {}
      
      return {
        ...sessionSettings,
        ...serverSettings,
        ...shooterGameMode
      }
    } catch (error: any) {
      console.error('Error reading GameUserSettings.ini:', error)
      throw error
    }
  }

  /**
   * Write GameUserSettings.ini (legacy)
   */
  async writeGameUserSettings(configPath: string, config: ServerConfig): Promise<void> {
    try {
      const iniContent = {
        SessionSettings: {},
        ServerSettings: {},
        '/Script/ShooterGame.ShooterGameMode': {}
      }

      // Distribute settings to appropriate sections
      const sessionKeys = ['SessionName', 'MaxPlayers', 'ServerPassword', 'ServerAdminPassword']
      const serverKeys = ['DifficultyOffset', 'XPMultiplier', 'TamingSpeedMultiplier', 
                          'HarvestAmountMultiplier', 'ResourcesRespawnPeriodMultiplier']

      for (const [key, value] of Object.entries(config)) {
        if (sessionKeys.includes(key)) {
          iniContent.SessionSettings[key] = value
        } else if (serverKeys.includes(key)) {
          iniContent.ServerSettings[key] = value
        } else {
          iniContent['/Script/ShooterGame.ShooterGameMode'][key] = value
        }
      }

      const content = ini.stringify(iniContent)
      await writeFile(configPath, content, 'utf-8')
    } catch (error: any) {
      console.error('Error writing GameUserSettings.ini:', error)
      throw error
    }
  }

  /**
   * Read Game.ini
   */
  async readGameIni(configPath: string): Promise<any> {
    try {
      const content = await readFile(configPath, 'utf-8')
      return ini.parse(content)
    } catch (error: any) {
      console.error('Error reading Game.ini:', error)
      throw error
    }
  }

  /**
   * Write Game.ini
   */
  async writeGameIni(configPath: string, config: any): Promise<void> {
    try {
      const content = ini.stringify(config)
      await writeFile(configPath, content, 'utf-8')
    } catch (error: any) {
      console.error('Error writing Game.ini:', error)
      throw error
    }
  }

  /**
   * Merge configurations
   */
  mergeConfig(existing: ServerConfig, updates: Partial<ServerConfig>): ServerConfig {
    return {
      ...existing,
      ...updates
    }
  }

  /**
   * Validate configuration
   */
  validateConfig(config: ServerConfig): { valid: boolean; errors: string[] } {
    const errors: string[] = []

    // Validate max players
    if (config.MaxPlayers !== undefined && (config.MaxPlayers < 1 || config.MaxPlayers > 100)) {
      errors.push('MaxPlayers must be between 1 and 100')
    }

    // Validate difficulty offset
    if (config.DifficultyOffset !== undefined && (config.DifficultyOffset < 0 || config.DifficultyOffset > 1)) {
      errors.push('DifficultyOffset must be between 0 and 1')
    }

    // Validate multipliers (must be positive)
    const multipliers = ['XPMultiplier', 'TamingSpeedMultiplier', 'HarvestAmountMultiplier']
    for (const key of multipliers) {
      if (config[key] !== undefined && config[key] < 0) {
        errors.push(`${key} must be a positive number`)
      }
    }

    // Validate ports (must be in valid range)
    if (config.Port !== undefined && (config.Port < 1024 || config.Port > 65535)) {
      errors.push('Port must be between 1024 and 65535')
    }
    if (config.QueryPort !== undefined && (config.QueryPort < 1024 || config.QueryPort > 65535)) {
      errors.push('QueryPort must be between 1024 and 65535')
    }
    if (config.RCONPort !== undefined && (config.RCONPort < 1024 || config.RCONPort > 65535)) {
      errors.push('RCONPort must be between 1024 and 65535')
    }

    // Validate session name (warn about special characters)
    if (config.SessionName && /[!@#$%^&*()+=\[\]{}|\\;:<>?]/.test(config.SessionName)) {
      errors.push('SessionName contains special characters which may cause issues. Consider defining it in GameUserSettings.ini instead.')
    }

    return {
      valid: errors.length === 0,
      errors
    }
  }

  /**
   * Get default configuration
   */
  getDefaultConfig(): ServerConfig {
    return {
      SessionName: 'ARK Server',
      ServerPassword: '',
      ServerAdminPassword: 'admin123',
      MaxPlayers: 70,
      DifficultyOffset: 0.5,
      XPMultiplier: 1.0,
      TamingSpeedMultiplier: 1.0,
      HarvestAmountMultiplier: 1.0,
      ResourcesRespawnPeriodMultiplier: 1.0,
      AllowThirdPersonPlayer: true,
      ShowMapPlayerLocation: true,
      ServerPVE: true,
      EnablePVPGamma: false
    }
  }
}

// Export singleton instance
export const configManager = new ConfigManager()
